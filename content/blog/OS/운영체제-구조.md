---
title: 운영체제 구조
date: 2023-03-07 00:03:13
category: OS
thumbnail: { thumbnailSrc }
draft: false
---

> 이 글은 'Abraham Silberschatz, Peter Baer Galvin, Greg Gagne'의 『운영 체제』의 '챕터 2.운영체제 구조' 부분을 정리한 글입니다.

# 2. 운영체제 구조

# 들어가며

운영체제는 기본적으로 프로그램이 실행될 수 있는 환경을 제공해줍니다. 컴퓨터 시스템 구조 혹은 사용자의 특성에 따라 필요한 프로그램 혹은 환경이 다르기 때문에 이에 맞춰 운영체제 또한 그 구조가 달라집니다. 운영체제 구조를 살펴보기 전, 다음과 같은 관점에 맞춰 운영체제의 구조를 공부하는 것이 이해하는데 도움이 될 수 있습니다.

1. 운영체제가 제공하는 서비스
2. 운영체제가 사용자와 프로그래머에게 제공하는 인터페이스
3. 시스템의 구성요소와 그들의 상호 연결

# 운영체제 서비스

위에서 이야기한 것처럼, 운영체제는 프로그램이 실행되는 환경을 제공합니다. 운영체제마다 제공하는 서비스는 다르지만 공통적으로 제공하는 종류들이 있습니다. 아래는 공통적으로 주로 사용되는 운영체제의 대표적인 서비스입니다.

### 사용자 인터페이스(user interface)

대부분의 운영체제는 여러 형태로 제공되는 사용자 인터페이스(UI)를 제공합니다.

가장 일반적으로는 **그래픽 사용자 인터페이스(GUI)**가 있습니다. 그래픽이라는 키워드에서 알 수 있 듯 그래픽 사용자 인터페이스는 사용자와 하드웨어 및 소프트웨어 간의 상호작용을 **시각적인** 방식으로 제공하는 형태를 의미합니다. 아이콘, 메뉴, 버튼 등과 같이 시각적인 구성 요소를 사용하여 사용자와 컴퓨터 시스템 간의 상호작용을 제공하며, 이러한 구성요소는 마우스, 키보드, 터치스크린 등을 통해 사용자가 조작할 수 있습니다.

또 다른 인터페이스로는, **명령어 라인 인터페이스(CLI)**가 있습니다. 이 인터페이스는 GUI와 다르게 **텍스트 기반의 명령어**를 사용하여 사용자와 컴퓨터 시스템 간의 상호작용을 제공합니다. 사용자가 **명령 프롬프트(prompt)**에서 명령어를 입력하면, 컴퓨터는 해당 명령어를 해석하여 작업하는 형태로 구성되어 있습니다.

### 프로그램 실행(program execution)

운영체제는 프로그램을 메모리에 적재해 실행하는 서비스를 제공합니다. 또 실행하는 것 뿐만 아니라, 프로그램이 정상적으로 혹은 비정상적으로 실행이 끝나고 사용자에게 알릴 수 있어야 합니다.

### 입출력 연산(I/O operation)

어떤 프로그램은 입출력 장치를 필요로 하는 경우가 있을 수 있습니다. 이를 위해 운영체제는 입출력 장치를 사용한 연산을 제공합니다. 또한 보안적인 측면과 효율성을 위해, 사용자에게 입출력 장치에 대한 제어권을 주지 않고 운영체제가 입출력 장치를 관리합니다.

### 파일 시스템 조작(file system manipulation)

많은 프로그램에서 사용되는 데이터를 저장하거나 읽기 위해, 운영체제는 파일을 읽고 쓰는 서비스를 제공합니다. 명시적으로 파일을 생성할 수 있으며, 원하는 파일을 찾을 수 있고, 파일의 정보를 읽어올 수 있습니다. 또한, 파일 소유권에 기반하여 파일 혹은 디렉토리에 대한 접근을 허가하거나 거부할 수 있습니다.

### 통신(communication)

여러 프로세스가 메모리에 적재되어 실행되는 환경에서 프로세스 간의 정보를 교환해야 하는 경우가 있을 수 있습니다. 운영체제는 이러한 상황에서 프로세스 간의 정보를 교환하기 위한 통신 방법을 제공합니다.

### 오류 탐지(error detection)

운영체제는 발생할 가능성이 있는 모든 오류를 항상 의식하고 있어야 합니다. 또한 일관성 있는 계산을 보장하기 위해 각 오류에 대한 조치를 할 수 있어야 합니다. 운영체제마다 오류에 어떻게 대처하는지는 달라질 수 있어도 대처한다는 점은 동일합니다.

### 자원 할당(resource allocation)

다수의 프로세스나 다수의 작업이 동시에 실행되는 경우 각각에 자원을 할당해주어야 합니다. 운영체제는 이러한 상황에서 어떤 프로세스나 작업에 어떤 자원을 어떻게 효율적으로 할당할 수 있을지 결정합니다. 예를 들어, CPU를 최대한 효율적으로 사용하기 위해 운영체제는 CPU 스케줄링을 사용하여 각 프로세스에 CPU 자원을 할당합니다.

### 로그 작성(logging)

컴퓨터 서비스를 개선하기 위한 통계 자료 등을 위해 운영체제는 어떤 프로그램이 어떤 종류의 자원을 얼마나 사용하는지를 추적하고 이를 기록합니다.

### 보호와 보안(protection and security)

여러 사용자가 사용하는 컴퓨터 시스템 혹은 네트워크로 연결된 컴퓨터 시스템에서, 저장된 데이터 혹은 정보의 소유자는 이러한 데이터를 관리하고 통제하길 원합니다. 또 사용자가 아닌 프로세스 작업에서도, 한 프로세스는 다른 프로세스 혹은 운영체제의 작업을 방해해서는 안됩니다. 이와 같이 전반적인 시스템 자원에 대한 접근을 통제하는 것을 **보호(protection)**이라고 하며, 운영체제는 이러한 보호 기능을 제공합니다.

**보안(security)**는 네트워크 어댑터 등과 같은 외부 입출력 장치들에 대한 부적절한 접근을 차단하고, 부적절한 접근 탐지를 위해 접속 기록을 남기는 등의 방법을 의미합니다.

# 사용자와 운영체제 인터페이스

위에서 설명한 것처럼, 운영체제는 사용자가 컴퓨터 시스템과 상호작용을 돕는 여러 인터페이스(GUI, CLI)를 제공하고 있습니다. 이 섹션에서는 이러한 인터페이스에 대해 자세히 다룹니다.

## 명령어 인터페이스(Command Interface)

**명령어 인터페이스는 사용자가 명령어를 입력하면, 명령어를 해석하여 시스템이 해당 명령어를 실행하는 구조로 구성된 인터페이스입니다.** 위에서 설명한 명령어 라인 인터페이스(CLI)도 명령어 인터페이스 중 하나로 **텍스트 기반**의 명령어 인터페이스입니다. 일반적으로 명령어 인터페이스를 제공하는 여러 운영체제에서 이러한 명령어를 해석하는 인터프리터를 **쉘(shell)**이라고 부릅니다.

명령어 인터프리터의 중요한 기능은 **사용자가 지정한 명령어를 가져와서 수행하는 기능**입니다. 이러한 기능은 일반적으로 두 가지 방법으로 구현됩니다.

첫번째 방법은 명령어 **인터프리터 자체가 사용자가 입력한 명령어를 직접 실행하는 코드를 갖도록 구현하는 방법**입니다. 사용자가 명령어를 입력하면, 명령어 인터프리터는 실행되는 코드에서 해당 명령어를 처리하는 코드로 분기하여, 분기된 코드 내부에서 적절한 시스템 콜을 사용하는 등의 처리를 통해 입력된 명령어를 처리하는 방식으로 동작합니다. 이러한 구현 방법은 명령어 처리를 위한 내부 코드를 포함하고 있기 때문에 처리 속도가 빠르며, 명령어 처리 과정이 노출되지 않기 때문에 보안상의 이점이 있다는 장점이 있습니다. 그러나 모든 명령어에 대한 내부 코드를 구현해야 하므로 구현이 복잡해지며, 명령어 인터프리터의 크기가 커진다는 단점이 있습니다. 또한 새로운 명령어가 추가되거나 기존 명령어가 수정되는 경우 명령어 인터프리터 자체가 변경되어야 한다는 단점도 존재합니다.

두번째 방법은 **명령어를 처리하는 시스템 프로그램을 구현하여 명령어 인터프리터가 이 프로그램을 실행하도록 구현하는 방법**입니다. 예를 들어, UNIX에서 파일을 삭제하기 위해 사용되는 `rm` 명령어을 사용자가 입력하면 명령어 인터프리터는 `rm`이라고 불리는 실행 파일을 찾아 그 파일을 메모리에 적재하고 매개변수를 사용하여 파일을 삭제하는 방식으로 동작합니다. 이러한 구현 방법은 해당 명령어 처리를 위한 코드를 명령어 인터프리터에 포함시킬 필요가 없기 때문에 명렁어를 추가하거나 변경하기 쉬우며, 시스템 프로그램을 활용하여 다양한 기능을 제공할 수 있다는 장점이 있습니다. 그러나 시스템 프로그램을 호출하는 과정에서 오버헤드가 발생하여 상대적으로 느리다는 단점과 명령어 처리 과정이 노출되어 보안상의 이슈가 발생할 가능성이 있다는 단점이 있습니다.

## 그래픽 기반 인터페이스(Graphical User Interface)

**그래픽 기반 인터페이스는 시각적인 구성요소를 사용하여 컴퓨터 시스템과의 상호작용을 제공하는 인터페이스입니다.** 사용자 친화적인 인터페이스로 마우스, 키보드 등의 입력 장치를 사용하여 컴퓨터 시스템과의 상호작용을 제공합니다. 일반적으로 데스크탑 운영체제에서 사용되며 맥, 윈도우, 리눅스 등 대부분의 운영체제에서 GUI를 제공합니다.

그래픽 기반 인터페이스는 사용자가 쉽게 작업하도록 직관적인 인터페이스를 제공하지만 그래픽 요소를 사용하기 때문에 상대적으로 자원을 많이 소모하며 느리게 동작할 수 있다는 단점이 있습니다.

## 터치스크린 인터페이스(Touch-Screen Interface)

대부분의 모바일 환경에서 제공하는 인터페이스로, 터치스크린을 사용하여 컴퓨터 시스템과의 상호작용을 제공합니다. 모바일 환경에서는 일반적으로 마우스 및 키보드를 사용하기 어렵기 때문에 터치스크린을 사용한 인터페이스가 발전되었으며, 사용자는 터치스크린에서 손가락을 사용하여 구성요소를 누르거나 스와이프 하는 등의 제스처를 통해 상호작용합니다.

# 시스템 콜(System Call)

시스템 콜은 프로그램이 하드웨어 자원에 직접 접근하지 않고, 운영체제에게 해당 서비스를 요청하기 위해 운영체제에서 제공하는 인터페이스로, 일반적으로 C와 C++로 구현되어 있습니다. 프로그램이 직접 하드웨어를 제어하는 경우 안정성과 보안에 문제가 발생할 수 있으므로 대신 운영체제가 제공하는 시스템 콜을 사용하여 필요한 기능을 호출하여 사용합니다. 시스템 콜은 보통 라이브러리 함수와 유사한 방식으로 동작합니다. 프로그램은 시스템 콜을 호출하여 운영체제에게 요청을 보내고 운영체제는 해당 요청을 처리한 뒤 결과를 반환합니다.

## 응용 프로그래밍 인터페이스(Application Programming Interface)

위와 같은 이유로 많은 프로그램에서는 시스템 콜을 통하여 운영체제에 필요한 기능을 호출하여 기능을 구현하고 있습니다. 그러나 일반적으로 개발자나 응용 프로그램은 시스템 콜을 직접 호출하는 것보다 시스템 콜을 추상화한 API를 사용합니다.

API는 운영체제의 기능을 추상화 했으므로 운영체제가 변경되더라도, API를 사용하여 구현된 프로그램은 영향을 받지 않습니다. 따라서 어느 운영체제를 사용한 컴퓨터 시스템에서도 동일하게 작동할 것을 기대할 수 있습니다. 또 API를 사용하는 경우 시스템 콜을 호출하기 위한 복집한 로직을 구현할 필요 없이 API를 호출하여 해당 기능을 사용할 수 있기 때문에 비용과 복잡성을 줄일 수 있다는 장점이 있습니다.

## 실행 시간 환경(RTE, Runtime Environment)

실행 시간 환경은 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 시스템 콜 인터페이스를 제공하는 것을 의미합니다. 시스템 콜은 보통 운영체제 커널 내부에서 실행되는데, 사용자 프로세스가 시스템 콜을 호출하는 경우 상태를 유지하면서 운영체제의 커널로 진입하여 시스템 콜을 진행할 수 있어야 합니다. 이를 위해 운영체제가 제공하는 환경이 실행 시간 환경, RTE 입니다. 실행 시간 환경은 시스템 콜을 호출하는 프로세스의 현재 상태를 저장하고, 시스템 콜이 실행을 마치고 나서 이 상태를 사용하여 프로세스가 정상적으로 다시 실행할 수 있도록 합니다.

따라서 **시스템 콜을 호출하는 당사자는 시스템 콜이 어떻게 구현되어 있고, 실행 중에 어떤 작업이 수행되는지 알 필요 없이 API에 의해 숨겨지고 RTE에 의해 관리되어, 시스템 콜을 사용하는 사용자는 단순히 API를 준수하고 운영체제가 무엇을 하는지만 이해**하고 있으면 됩니다.

## 시스템 콜의 유형

시스템 콜은 크게 5가지의 유형으로 구분될 수 있습니다. 아래는 5가지에 대한 시스템 콜의 유형에 대한 설명을 다룹니다.

### 프로세스 제어(Process Control)

시스템 콜을 사용하여 실행 중인 프로그램(프로세스)를 정상적(end)으로 혹은 비정상적(abort)으로 종료시킬 수 있습니다. 만약 프로세스가 비정상적으로 종료해야 하기 위해 시스템 콜을 호출하는 경우, 메모리 덤프가 실행되며 오류 메세지를 표시할 수 있습니다.

또한, 한 프로세스가 다른 프로그램을 메모리에 적재하고 실행시킬 수도 있습니다. 이 때 새로 실행된 프로그램이 종료되어 기존 프로그램으로 돌아가기 위해 기존 프로그램의 메모리 이미지를 보관해야 합니다. 이러한 목적을 위해 시스템 콜(create_process)을 사용할 수 있습니다.

새로운 프로세스 생성 및 종료 외에도 시스템 콜을 사용하여 실행 중인 프로세스를 제어할 수 있습니다. 프로세스의 우선 순위와 최대 허용 시간 및 프로세스의 속성들을 가져오고(get_process_attributes) 재설정(set_process_attributes)하는 등의 행동도 시스템 콜을 통해 동작할 수 있습니다.

여러 개의 프로세스가 실행되는 환경에서 프로세스 간의 데이터 공유가 발생할 수도 있는데, 공유되는 데이터의 일관성을 위해 운영체제는 종종 해당 공유 데이터를 잠그기 위한 시스템 콜(lock)도 제공합니다.

### 파일 조작(File Manipulation)

파일도 운영체제에서 제공하는 시스템 콜을 통해 다룰 수 있습니다. 먼저 파일을 생성(create)하고 삭제(delete)할 수 있습니다. 생성된 파일은 파일 이름을 통해 열고(open), 파일 내용을 읽거나(read) 쓰는(write) 행위도 가능합니다. 해당 파일의 조작이 끝난 경우 파일을 닫아(close) 해당 파일의 조작을 끝냅니다.

파일을 생성하거나 읽고 쓰는 행위 외에도, 파일의 정보를 가져올 수 있습니다. 파일의 속성을 가져오거나(get_file_attribute) 설정(set_file_attribute)할 수 있으며, 파일의 위치를 이동(move)하거나 복사(copy)할 수 있습니다.

### 장치 관리(Device Management)

프로세스가 실행되는 중에 다른 컴퓨터 자원을 필요로 하는 경우가 있을 수 있습니다. 이 때 필요한 컴퓨터 자원에는 메모리에 저장된 데이터 외에도 외부 입출력 장치에서 필요로 자원이 있을 수 있습니다. 이러한 자원을 얻기 위해서 입출력 장치를 사용하게 되는데, 입출력 장치에 대한 접근을 시스템 콜을 통해 작업할 수 있습니다.

입출력 장치에 접근하는 사용자가 여러 명일 수 있으므로 운영체제는 입출력 장치를 사용하기 위해 먼저 해당 장치에 대한 요청(request)를 필요로 합니다. 요청을 통해 해당 입출력 장치에 대한 접근 권한을 얻고 사용이 끝나면 해당 장치를 해제(release)해야 합니다. 입출력 장치에 대한 시스템 콜 기능은 파일 조작에서의 시스템 콜 사용과 비슷하게 사용됩니다.

### 정보 유지(Information Maintenance)

시스템 콜에는 프로세스나 자원 등을 관리하기 위한 기능 외에도 특정 정보를 얻기 위해 사용되는 시스템 콜이 있습니다. 예를 들면, 현재 시간(time)과 현재 날짜(date)를 반환하는 시스템 콜이 있습니다. 이 외에도 운영체제의 버전 번호, 메모리 및 디스크 공간의 정보를 알려주는 시스템 콜 등이 있습니다.

시스템 정보 외에도, 메모리를 덤프(dump)하는 시스템 콜을 통해 디버깅을 유용하게 할 수 있으며, 프로그램의 시간 프로파일(time profile)을 통해 여러 프로그램의 통계를 얻을 수 있습니다.

### 통신(Communication)

기본적으로 통신 방법에는 크게 **메세지 전달**과 **공유 메모리**가 있습니다.

**메세지 전달** 방법은 통신하는 두 프로세스가 정보를 교환하기 위해 메세지를 주고 받는 방법으로, 두 프로세스가 직접 메세지를 주고 받거나, 버퍼와 메세지 큐를 통해 간접적으로 주고 받을 수 있습니다.

직접 메세지를 주고 받는 방법은 **직접 통신 방법(Direct Communication)**으로, 송신자가 명시적으로 수신자를 지정하여 메세지를 전송합니다. 이 때 수신자는 송신자의 식별자(프로세스 이름)(get_hostid, get_processid)을 알고 있어야 하며, 송신자와 동시에 수신자와 연결됩니다.

버퍼와 메세지 큐를 사용하는 방법은 **간접 통신 방법(Indirect Communication)**으로, 송신자와 수신자가 직접 통신하지 않고, 커널이나 운영체제의 중계를 통해 통신하는 방법입니다. 커널은 메세지를 버퍼에 저장하고, 메세지 큐를 통해 송신자와 수신자를 연결합니다. 따라서 송신자와 수신자는 서로를 모르며, 커널이 중간에서 관리하는 형태입니다.

**공유 메모리** 방법은 프로세스들이 동일한 메모리 영역을 공유하며 통신하는 방법입니다. 일반적으로 각 프로세스는 독립적으로 실행되기 때문에 메모리 공간을 공유하지 않지만, 공유 메모리 방법을 사용하면 공유 메모리 영역을 프로세스의 메모리 공간처럼 사용하여 여러 프로세스 간의 데이터를 공유하는 방식으로 사용할 수 있습니다. 먼저 공유 메모리 세그먼트를 생성(shared_memory_create)하고, 생성된 공유 메모리 세그먼트에 프로세스의 가상 주소 공간에 연결(shared_memory_attach)하여 공유 메모리 공간에 접근할 수 있습니다.

일반적으로 메세지 전달 방법은 소량의 데이터를 주고 받을 때 유용합니다. 공유 메모리 방법과 다르게 충돌이 발생하지 않기 때문입니다. 또 공유 메모리 방법보다 구현하기 쉽다는 장점이 있습니다. 반대로 공유 메모리 방법은 한 컴퓨터 내에서 메모리를 사용하여 데이터를 공유하기 때문에 메모리 전송하는 것과 동일한 속도로 데이터를 공유할 수 있다는 장점이 있습니다. 그러나 데이터 보호와 동기화 부분에서 문제가 발생할 가능성이 있습니다.

### 보호(Protection)

보호는 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 방법입니다. 이전에는 다중의 사용자를 갖는 다중 프로그램 시스템에서만 고려되는 문제였으나, 현대에는 네트워킹과 인터넷의 발전으로 서버에서 휴대용 컴퓨터까지 전반적인 모든 컴퓨터 시스템에서 고려해야 하는 사항이 되었습니다.

보호에 주로 사용되는 시스템 콜은 파일 같은 시스템 자원의 허가 권한을 설정하는데 사용되는 시스템 콜(set_permission)과 권한 정보를 가져오는 시스템 콜(get_permission)이 주로 사용됩니다.

# 시스템 서비스(System Service)

**시스템 유틸리티(system utility)로도 알려진 시스템 서비스는 프로그램 개발과 실행을 위해 다양한 기능을 제공합니다.** 주로 프로그램이 직접 실행할 수 없는 하드웨어 관리, 파일 및 디렉토리 관리, 프로세스 관리, 메모리 관리 등의 특정한 작업을 수행합니다. 일반적으로 시스템 서비스는 두 가지 방식으로 제공됩니다. 하나는 커널 내부에 구현된 서비스로서 제공되며, 다른 하나는 라이브러리의 형태로 제공되는 시스템 서비스입니다.

시스템 서비스가 주로 제공하는 기능은 다음과 같습니다.

- 파일 관리
- 상태 정보
- 파일 변경
- 프로그래밍 언어 지원
- 프로그램 적재와 수행
- 통신
- 백그라운드 서비스

# 링커와 로더(Linker and Loader)

일반적으로 프로그램은 디스크에 **이진 실행 파일(binary executable file)**로 존재합니다. 이 프로그램을 CPU가 실행하기 위해서는 프로그램을 메모리로 가져와 프로세스 형태로 배치되는 과정이 필요합니다. 이 섹션에서는 프로그램을 컴파일하고 메모리에 적재하여 CPU 코어에서 실행하기까지의 과정을 다룹니다.

먼저 프로그램은 소스 파일에서 오브젝트 파일로 컴파일 됩니다. 이렇게 컴파일 된 오브젝트 파일을 **재배치 가능 오브젝트 파일**이라고 부릅니다. 이렇게 생성된 오브젝트 파일들을 **링커**가 **하나의 이진 실행 파일로 결합**합니다. 이러한 작업을 **링킹(linking)**이라고 부르며, 이 단계에서 표준 C 라이브러리와 같이 다른 오브젝트 파일이나 라이브러리가 포함될 수 있습니다.

**로더**는 이렇게 생성된 이진 실행 파일을 메모리에 적재하는데 사용됩니다. 적재된 이진 실행 파일은 CPU 코어에서 실행할 수 있는 상태가 됩니다. 링커와 로더가 주로 하는 작업은 **재배치**와 관련된 작업으로, 작성된 프로그램에 최종으로 실행될 주소를 부여하고, 프로그램의 코드와 데이터가 해당 주소에 일치하도록 설정하여 프로그램이 실행될 때 코드가 라이브러리를 호출하고 변수에 접근할 수 있도록 합니다.

앞서 설명한 과정은 라이브러리가 오브젝트 파일을 생성할 때 링크되는 것을 기준으로 설명했으나, 프로그램이 메모리에 적재되는 순간에 라이브러리가 링크되도록 할 수도 있습니다. 실제로 대부분의 시스템에서는 동적으로 라이브러리를 링크하도록 구성되어 있으며, 이러한 동적 링크 방식은 해당 라이브러리가 필요한 순간에 링크하고 로드할 수 있습니다. 이로 인해 이 프로그램을 실행하는 여러 프로세스가 동적으로 링크된 라이브러리를 공유할 수 있어 메모리 사용이 크게 절약할 수 있다는 장점이 있습니다. 이러한 동적 링크 방식은 컴파일 시에 라이브러리 대신 재배치 정보를 삽입하고, 라이브러리의 함수를 호출 할 때 라이브러리 코드가 재배치 정보를 사용하여 메모리에 로드되는 형태로 작동합니다.

컴파일 된 오브젝트 파일 및 실행 파일은 일반적으로 표준화된 형식을 가지고 있습니다. 예를 들어 UNIX 및 Linux 시스템의 경우 ELF(Executable and Linkable Format)이라는 표준 파일 형식을 사용하고 있습니다. 이렇게 표준화된 형식을 사용하면 운영체제나 아키텍처에 상관없이 동일한 파일 형식으로 프로그램을 작성하고 배포할 수 있다는 장점이 있습니다. 이러한 장점은 소프트웨어 개발과 배포의 비용 절감으로 이어집니다. 또 표준화된 파일 형식을 사용하면 공통적인 보안 기능을 포함하여 악성 코드 등과 같은 문제로부터 보호할 수 있는 보안성을 얻을 수 있습니다.

# 운영체제 구조

현대의 운영체제는 크고 복잡하기 때문에 적절하게 동작하고 쉽게 변경되려면 신중하게 구조가 잡혀야 합니다. 이 섹션에서는 운영체제의 구조의 종류에 대해서 다룹니다.

## 모놀리식 구조(Monolithic Structure)

운영체제를 구성하는 가장 간단한 구조로, 커널의 모든 기능을 단일 실행 파일에 넣는 구조입니다. 최초의 UNIX 운영체제가 이러한 모놀리식 구조로 구현되었으며, 단일 커널과 시스템 프로그램으로 구성되었습니다. 이러한 모놀리식 구조는 **단순한 구조를 가지고 있어 확장하기 어렵다는 단점**이 있습니다. 그러나 **시스템 콜 인터페이스에서 오버헤드가 거의 없고 커널 내에서 통신 속도가 빠르다는 장점**이 있습니다.

## 계층형 구조(Hierarchical Structure)

모놀리식 구조와 같은 단일 구조는 운영체제의 한 부분을 변경하면 다른 부분에 영향을 줄 수 있습니다. 이 대신, 운영체제를 개별적으로 독립된 작은 구성요소로 나눈 뒤, 이 구성요소를 합쳐서 커널을 구성하는 방법이 있습니다. 이러한 구조의 장점은 한 구성 요소에 변경이 있으면, 해당 구성 요소 내에서만 영향이 존재하며 다른 구성 요소에는 영향이 없습니다. 따라서 운영체제의 내부 작동을 더 자유롭게 변경할 수 있다는 장점이 있습니다.

이러한 구조 중 대표적인 구조가 **계층형 구조**입니다. 계층형 구조에서는 운영체제가 여러 계층으로 구분되어, 최하위 층은 하드웨어, 최상위 층은 사용자 인터페이스로 구성되어 있습니다. 하나의 계층에서는 아래 계층의 루틴을 호출하여 하나의 루틴을 이루는 형태로 구성되어 있습니다. 이러한 계층형 구조의 대표적인 장점은 **구현과 디버깅이 간단하다는 점**입니다. 각 계층은 하위층들의 서비스와 기능들만을 사용해서 구현되기 때문에, **최하위 층에서부터 시작하여 특정 층에서 오류나 문제가 발생하는 경우, 하위층은 이미 검증되었기 때문에 해당 층에서 반드시 오류나 문제가 있음을 보장**할 수 있습니다. 또한 한 계층은 하위층의 서비스와 기능들을 사용하여 구현되기 때문에 **내부적으로 어떻게 구현되어 있는지 알 필요 없이 해당 서비스와 기능이 어떻게 작동하는지만 알고 있으면 된다는 장점**이 있습니다. 그러나 **이러한 구조는 하나의 완성된 서비스를 위해 여러 계층을 통과해야 하기 때문에 상당한 오버헤드가 있다는 단점**이 있습니다.

## 마이크로 커널(Micro-Kernel)

마이크로 커널 구조는 커널에 중요한 구성요소만 남겨두고, 나머지 필요한 서비스와 구성요소는 별도 프로그램으로 구현하여 운영체제를 구성하는 방법입니다. 마이크로 커널 방식의 장점은 운영체제의 확장이 매우 쉽다는 점입니다. **새로운 서비스를 추가하는 경우 해당 서비스를 별도의 프로그램으로 작성하여 추가만 하면 되므로 커널을 변경할 필요가 없습니다.** 또 **서비스 대부분이 커널이 아니라 사용자 프로세스로 작동하므로 높은 보안성과 신뢰성을 제공**합니다. 만약 한 서비스에서 문제가 발생하더라도 운영체제의 다른 부분에는 영향을 받지 않습니다. 그러나 마이크로 커널은 **별도의 프로그램으로 실행되는 특징으로 인하여 발생하는 오버헤드로 성능이 나쁘다는 단점**이 있습니다.

## 모듈(Module)

운영체제를 구성하는 구조 중 다른 하나는 **모듈**을 사용하는 방식입니다. **로드 가능한 커널 모듈(Loadable Kernel Modules, LKM)** 방식이라고 부르는 이 방식은 **런타임 시에 부가적인 서비스들을 모듈 형태로 링크**하여 사용하는 방식을 의미합니다.

이 구조의 핵심은 핵심 서비스들은 커널을 통해 제공하고, 부가적인 서비스들은 커널이 실행되는 동안 동적으로 모듈을 통해 제공하는 것입니다. 모듈 구조는 운영체제의 유지보수가 편리하고 확장성이 높다는 장점이 있습니다. 운영체제에 새로운 기능이 추가되는 경우 해당 기능을 사용하는 모듈을 추가하거나, 수정하는 경우 수정된 모듈만 교체하는 식으로 구성할 수 있습니다.

또한 모듈들은 인터페이스를 가지기 때문에 하나의 모듈에서 또 다른 모듈을 불러와 사용할 수 있다는 점에서 계층형 구조보다 유연한 구조를 가지고 있습니다.
